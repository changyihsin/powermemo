/* vi: set sw=4 ts=4: */
/*
 * addr2line.c,
 *
 * Copyright (C) 2011 by Vincent Chang <changyihsin@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>
#include <string.h>

#define MAX_MSG_LEN	2000
#define MAX_CMD_LEN 128

extern int optind;
extern char *optarg;
char file_name[256];
int is_file_name=0;
char func_name[256];
int is_func_name=0;
char bin_name[256];
int is_bin_name=0;
char asm_name[256];
int is_asm_name;
int line_num=0;


int run_shell(char * buf, int size, const char * format, ...)
{
    FILE * fp;
    int i, c;
    char cmd[MAX_CMD_LEN];
    va_list marker;

    va_start(marker, format);
    vsnprintf(cmd, sizeof(cmd), format, marker);
    va_end(marker);

    fp = popen(cmd, "r");
    if (fp)
    {
        for (i = 0; i < size-1; i++)
        {
            c = fgetc(fp);
            if (c == EOF) break;
            buf[i] = (char)c;
        }
        buf[i] = '\0';
        pclose(fp);

        /* remove the last '\n' */
        i = strlen(buf);
        if (buf[i-1] == '\n') buf[i-1] = 0;
        return 0;
    }
    buf[0] = 0;
    return -1;
}

/* 
 * string library 
 */

int isEmpty(const char *s)
{
	if(s == NULL)
		return 1;
	if(*s == 0)
		return 1;
	return 0;
}

char *ltrim(char *str)
{
	if(str == NULL)
		return NULL;
	while(*str == ' ' || *str == '\t')
		str++;
	return str;
}

char *rtrim(char *str)
{
	char *index;
	
	if(str == NULL)
		return NULL;
	if(*str == 0)
		return str;
	index = str + strlen(str) - 1;
	while(*index == ' ' || *index == '\t')
	{
		*index = 0;
		if(index > str)
			index--;
	}
	return str;
}
char *trim(char *str)
{
	return(ltrim(rtrim(str)));
}
char *strsep(char **stringp, const char *delim)
{
	char *s;
	const char *spanp;
	int c, sc;
	char *tok;

	if ((s = *stringp) == NULL)
		return (NULL);
	for (tok = s;;) {
		c = *s++;
		spanp = delim;
		do {
			if ((sc = *spanp++) == c) {
				if (c == 0)
					s = NULL;
				else
					s[-1] = 0;
				*stringp = s;
				return (tok);
			}
		} while (sc != 0);
	}
}

/* Extract token from string and remove leading and trailing blanks */
char *strsep_t(char **stringp, const char *delim)
{
	return trim(strsep(stringp, delim));
}

char *get_line(char **stringp)
{
	char *line;

	if(*stringp == NULL)
		return NULL;
	line = strsep(stringp, "\n");
	if(line == NULL)
		return NULL;
	line = strsep(&line, "\r");
	
	return trim(line);
}
int isHexDigit(char x)
{
    if ((x >= 0x30) && (x <= 0x39))
        return 1;
    else if ((x >= 0x41) && (x <=0x46))
        return 1;
    else if ((x >= 0x61) && (x <= 0x66))
        return 1;
    
    return 0;
}
int isAddress(char *str)
{
	char *ch=NULL;

	ch=str;
	while (ch && *ch != 0)
		if (isHexDigit(*ch++) == 0)
			return 0;
	return 1;
}

char *get_FuncName(char **str)
{
	char *tmp_str;

	tmp_str=strsep(str, "<");
	if (tmp_str == NULL)
		return NULL;
	printf("function addr:%s\n", tmp_str);
	tmp_str=strsep(str, ">");
	printf("FuncName=%s\n", tmp_str);
	return tmp_str;
}
static void show_usage(int exit_code)
{
    printf("Usage: line2addr [OPTIONS]\n"
            "  -h                	show this help message.\n"
            "  -s  [file name]      source code file name\n"
            "  -f  [function name]	source code function name\n"
			"  -l  [line number]	line number in the source code\n"
			"  -a  [assembly code]  assembly file generated by (arch)-objdump\n"
			"  -e  [binary name]	executable file name, vmlinux, userspace application\n");			
    exit(exit_code);
}

static void parse_args(int argc, char * argv[])
{
    int opt, i;

	//for (i = 0; i < argc; i++)
	//	printf("%d %s\n", i, argv[i]);

    while ((opt = getopt(argc, argv, "ha:s:f:l:e:")) > 0)
    {
        switch (opt)
        {
        	case 'h':   show_usage(0);                  break;
        	case 's': 
				strcpy(file_name, optarg);
				is_file_name++;
				//printf("source file name: %s\n", file_name); 				                         
				break;						
        	case 'f':   
				strcpy(func_name, optarg);   
				is_func_name++;
				//printf("function name: %s\n", func_name);
				break;
        	case 'l':   
				line_num = atoi(optarg);     
				//printf("line number: %d\n", line_num);    
				break;
            case 'a':
                strcpy(asm_name, optarg);
				is_asm_name++;
                //printf("assembly file name: %s\n", asm_name);
                break;
			case 'e':		
				strcpy(bin_name, optarg);
				is_bin_name++;
				//printf("binary: %s\n", optarg);
				break;
        	default:    show_usage(-1);                 break;
        }
    }
}
/*
 *	main function for this program
 */
void main(int argc, char *argv[])
{
	int i = 0, fdsrc, numbytes, len, first_time = 0, got_function = 0;
	char fname[] = "vmlinux.asm";
	char *str=NULL, *line=NULL, *fun=NULL;	
	char *header=NULL, *cmd=NULL;
	char *buf, ch, *cmd_buf;
	char addrcmd[256];
	struct stat filestat;

	parse_args(argc, argv);	
	/* read the assembly file, it must have function name and code and its address */
	if (is_bin_name == 0 || is_asm_name == 0) {
		printf("You should specify binary or assembly file name\n");
		exit(-1);
	}

	if((fdsrc = open(asm_name, O_RDONLY)) < 0) {
		perror("open fdsrc");
		exit(EXIT_FAILURE);
	}
	
	fstat(fdsrc, &filestat);	
	buf=malloc(filestat.st_size);

	if (buf == NULL){
		printf("allocate memory fail\n");
		exit(EXIT_FAILURE);
	}
	cmd_buf=malloc(1024);

	if (cmd_buf == NULL) {
		printf("allocate command output fail\n");
		exit(EXIT_FAILURE);
	}

	/* read up to 10 bytes, write up to 10 bytes */
	while ((numbytes = read(fdsrc, buf, filestat.st_size)) != 0) {
		str=buf;

		while(1) {
		
			line=get_line(&str);
				
			if (line == 0)
				break;

			if (line && *line == 0)
				continue;
					
			header = strsep_t(&line, ":");
			cmd = strsep_t(&line, "\n");	
			
			/* try to find start of function */
			if (isAddress(header) == 0){
				if (strcmp(header, "...") == 0)
					continue;
				fun=get_FuncName(&header);
				if (fun != NULL) {
					if (strcmp(fun, func_name) == 0) {
						first_time=1;
						got_function=1;
					}else{
						if (got_function == 1){
							printf("Selected line is not in Function:%s\n", func_name);
							exit(EXIT_FAILURE);
						}
					}	
				}	
				continue; 
			}
			/* check the function name */
			if (fun != NULL && strcmp(fun, func_name) == 0 ) {
				char *src_file,*src_line = NULL;
				
				sprintf(addrcmd, "%s %s %s %s\n", "addr2line -e", bin_name, "-f", header);
				run_shell(cmd_buf, 1024, "%s", addrcmd);
				src_line=cmd_buf;
				/* 
 				 *	decode the output from addr2line 
 				 *  output format:
 				 *  schedule
 				 *  /kernel/sched.c:3280
 				 */					
				src_file=strsep(&src_line, "\n");
				if (src_line != NULL) {
					src_file=strsep(&src_line, ":");
					if (src_file != NULL && src_line != NULL) {
						src_file=strrchr(src_file, '/'); 
						if (src_file != NULL) {
							/* skip '/' and get the source file name, sched.c */
							if (*src_file == '/')
								src_file++;		
					
							/* now we have file name/line number = src_file/src_line */
							if (line_num > 0) {
								/* we just enter the function, check to see if line_num is in this function */
								if (first_time == 1) { 
									if (atoi(src_line) > line_num) {
										printf("Selected line is not in Function:%s\n", fun);
										exit(EXIT_SUCCESS);
									}
									first_time=0;
								}
								if (atoi(src_line) >= line_num){	
									printf("%s:%s:%d:%s:%s\n", src_file, src_line, line_num, header, cmd);
									exit(EXIT_SUCCESS);
								}
							}
						}
					}else {
						printf("can't get the source file name and line number\n");
						exit(EXIT_FAILURE);
					}

				}
				else {
					printf("can't get source file name and line number\n");
					exit(EXIT_FAILURE);
				}				
			}
		}
	}
	printf("Selected line is not in Function:%s\n", func_name);
	/* close our files and exit */
	close(fdsrc);
	exit(EXIT_SUCCESS);
}
